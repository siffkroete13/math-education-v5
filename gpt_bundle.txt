# FILE C:\Homepage\math-education-v5\src\app\index.js

/*
Mathematik
  â†“
Koordinatensystem / Vektoren / Basen
  â†“
GeometryBuilder (Ãœbersetzer)
  â†“
Geometry (positions, colors)
  â†“
Model_VOB (WebGL / GPU)
  â†“
Shader â†’ Pixel

ARCHITEKTURÃœBERSICHT â€“ MATHE / GEOMETRIE / RENDERING

Dieses Projekt ist bewusst didaktisch aufgebaut.
Ziel ist nicht â€žEngine-Benutzungâ€œ, sondern Verstehen:
Vektoren, Matrizen, RÃ¤ume, Projektion, Pixel.

---------------------------------------------------
1) MATHE (src/math)
---------------------------------------------------
Hier lebt die Bedeutung.

- Vektoren
- Basen
- lineare Abbildungen
- Basiswechsel (nicht zu verwechseln mit View-Matrix, die macht auch basiswechsel aber auf Infrastruktur-Ebene, das hier ist didaktisch)
- explizite Rechnungen

WICHTIG:
Mathe weiss NICHTS von WebGL, Shadern oder Rendering.
Mathe arbeitet nur mit Zahlen.

---------------------------------------------------
2) BUILDERS (src/builders)
---------------------------------------------------
Builder sind die BrÃ¼cke zwischen Mathe und Darstellung.

Aufgabe:
- nehmen mathematische Konzepte
- erzeugen daraus GEOMETRIE

Beispiele:
- CoordinateSystemBuilder â†’ Achsen aus Basis
- CubeBuilder â†’ WÃ¼rfel aus Vektoren
- VectorBuilder â†’ Pfeil aus Richtungsvektor

Builder:
- enthalten Mathematik
- erzeugen nur Daten
- geben Geometry-Objekte zurÃ¼ck

Builder machen KEIN Rendering.

---------------------------------------------------
3) GEOMETRY (Datenformat)
---------------------------------------------------
Geometry ist ein reines dummes Datenobjekt:

{
  positions: [...],
  colors: [...],
  primitives: "LINES",
  num_vertices: ...
}

Geometry:
- enthÃ¤lt KEINE Bedeutung
- enthÃ¤lt KEINE Transformation
- ist nur â€žwas gezeichnet werden sollâ€œ

---------------------------------------------------
4) RENDERING (src/render)
---------------------------------------------------
Rendering ist Darstellung, nicht Bedeutung.

- Drawable:
  - lÃ¤dt Geometry auf die GPU
  - fÃ¼hrt drawArrays aus
  - kennt keine Mathe-Bedeutung

- Scene:
  - orchestriert alles
  - kennt Kamera & Projektion
  - zeichnet Drawables

- Camera:
  - erzeugt View-Matrix

- Projection:
  - erzeugt Projektionsmatrix (Frustum)

Rendering rechnet NICHT an der Geometrie.
Es zeigt nur das Ergebnis.

---------------------------------------------------
5) SHADER (src/shaders)
---------------------------------------------------
Shader sind AusfÃ¼hrungsmaschinen.

- nehmen Matrizen
- wenden sie auf Vertices an
- keine Logik, keine Bedeutung

Shader sind absichtlich â€ždummâ€œ.

---------------------------------------------------
6) WICHTIGE DESIGNENTSCHEIDUNG
---------------------------------------------------
Dieses Projekt verzichtet bewusst auf Model-Matrizen (diejenigen die das Objekt selber drehen, nicht die Welt.)
in frÃ¼hen Phasen.

Stattdessen:
- Geometrie wird explizit transformiert
- jede Zahl ist sichtbar
- jede Rechnung nachvollziehbar

---------------------------------------------------
MERKSATZ
---------------------------------------------------
Mathe erklÃ¤rt.
Builder formen.
Rendering zeigt.
Shader fÃ¼hren aus.

*/

// src/app/index.js
"use strict";

import { WorldConfig } from "../config.js";
import { Matrix3 } from "../math/Matrix3.js";
import { MathState } from "../state/MathState.js";
import { loadText } from "../loaders/loadText.js";
import { createProgram } from "../gl/createProgram.js";
import { bindLinearMapView } from "../ui/LinearMapView.js";
import { CoordinateSystemBuilder } from "../builders/CoordinateSystemBuilder.js";
import { CubeWireframeBuilder } from "../builders/CubeWireframeBuilder.js";
import { VectorBuilder } from "../builders/VectorBuilder.js";
import { loadExperiment } from "../experiments/loadExperiment.js";
import { Scene } from "../render/Scene.js";

async function start() {

	// 1) Canvas + WebGL
	const canvas = document.querySelector("#meineWebGLCanvas");
	const gl = canvas.getContext("webgl");
	if (!gl) {
		alert("WebGL nicht verfÃ¼gbar");
		return;
	}

	// 2) Shader laden
	const [vShaderCode, fShaderCode] = await Promise.all([
		loadText("/src/shaders/vShaderCode.glsl"),
		loadText("/src/shaders/fShaderCode.glsl"),
	]);

	const programInfo = createProgram(gl, vShaderCode, fShaderCode);
	gl.useProgram(programInfo.program);

	// 3) Scene
	const scene = new Scene(
		canvas,
		gl,
		programInfo
		/*
		{
			axes: CoordinateSystemBuilder.build(basisA, 1.0),
			cube: CubeWireframeBuilder.build(1.0)
		}
		*/
	);

	// 4) State (Wahrheit)
	const state = new MathState();

	// 5) UI an State binden (nur lesen)
	bindLinearMapView(state);

	// 6) Rendering an State binden (nur lesen)
	state.onChange((s) => {
		scene.clear();

		// optional: Raumreferenz
		scene.addGeometry(CubeWireframeBuilder.build(WorldConfig.EXTENT));

		// zwei Koordinatensysteme
		if (s.basisA) {
			scene.addGeometry(CoordinateSystemBuilder.build(
									s.basisA,
									WorldConfig.EXTENT,
									WorldConfig.TICK_STEP,
									WorldConfig.TICK_SIZE,
									[1,0,0,1]
				)
			);
		}

		if (s.basisB) {
			scene.addGeometry(CoordinateSystemBuilder.build(
									s.basisB,
									WorldConfig.EXTENT,
									WorldConfig.TICK_STEP,
									WorldConfig.TICK_SIZE,
									[0,1,0,1]
				)
			);
		}

		// Der Vektor
    	if (s.vector) {
			scene.addGeometry(
				VectorBuilder.build(s.vector, {
					color: [1,0,0,1]
				})
			);
		}

		// ðŸ”¥ Ergebnisvektor
		if (s.resultVector) {
			scene.addGeometry(
				VectorBuilder.build(s.resultVector, { color: [0,1,0,1] })
			);
		}

		scene.render();

	});

	// 7) Experiment laden und laufen lassen (schreibt State)

	// Basis um 20 Grad gedreht
	const ANZ_GRAD = 20;
	const theta = (ANZ_GRAD / 180) * Math.PI;

	// einfache lineare Abbildung (hier jetzt darstellung der neuen Basis mit alten Zahlen)
    const linearMapMatrix = new Matrix3([
        [Math.cos(theta), -Math.sin(theta), 0],
        [Math.sin(theta),  Math.cos(theta), 0],
        [0, 0, 1]
    ]);

    /*
	// In Zahlen: 20 Grad gedreht gegen Uhrzeigersinn
	const matrix = new Matrix3([
		[ 0.940, -0.342, 0 ],
		[ 0.342,  0.940, 0 ],
		[ 0,      0,     1 ]
	]);
	*/

	const experiment = await loadExperiment("linearMap");
	experiment.run(state, linearMapMatrix);
}

// DOM Ready
(function r(f) {
  	/in/.test(document.readyState) ? setTimeout(() => r(f), 9) : f();
})(start);

/*
Starten mit:

python -m http.server 8000

und dann aufrufen:

http://localhost:8000

Wenn es nicht funktioniert dann mit dem python extra script:

python server.py

*/

# FILE C:\Homepage\math-education-v5\src\builders\CoordinateSystemBuilder.js

// src/builders/CoordinateSystemBuilder.js
"use strict";

export class CoordinateSystemBuilder {

   static build(basis, length = 1, tickStep = 1, tickSize = 0.05, color = [1,0,0,1]) {

        const positions = [];
        const colors = [];

        function pushLine(a, b, color) {
            positions.push(
                a.x, a.y, a.z,
                b.x, b.y, b.z
            );
            colors.push(...color, ...color);
        }

        const axes = [
            { dir: basis.e1, ortho: basis.e2, color: color },
            { dir: basis.e2, ortho: basis.e1, color: color },
            { dir: basis.e3, ortho: basis.e1, color: color },
        ];

        for (const { dir, ortho, color } of axes) {

            // Achse
            pushLine(
                {
                    x: -dir.x * length,
                    y: -dir.y * length,
                    z: -dir.z * length
                },
                {
                    x:  dir.x * length,
                    y:  dir.y * length,
                    z:  dir.z * length
                },
                color
            );

            // Ticks
            for (let t = -length; t <= length; t += tickStep) {
                if (t === 0) continue;

                const center = {
                    x: dir.x * t,
                    y: dir.y * t,
                    z: dir.z * t
                };

                const offset = {
                    x: ortho.x * tickSize,
                    y: ortho.y * tickSize,
                    z: ortho.z * tickSize
                };

                pushLine(
                    {
                        x: center.x - offset.x,
                        y: center.y - offset.y,
                        z: center.z - offset.z
                    },
                    {
                        x: center.x + offset.x,
                        y: center.y + offset.y,
                        z: center.z + offset.z
                    },
                    color
                );
            }
        }

        return {
            primitives: "LINES",
            num_dim: 3,
            num_color: 4,
            num_vertices: positions.length / 3,
            positions,
            colors
        };
    }
}

# FILE C:\Homepage\math-education-v5\src\builders\CubeBuilder.js

// src/builders/CubeBuilder.js
"use strict";

/**
 * CubeBuilder
 * -----------
 * Erzeugt die Geometrie (LINES) eines WÃ¼rfels aus expliziter Mathematik.
 *
 * - KEIN WebGL
 * - KEINE Shader
 * - KEINE Kamera
 * - NUR: Vektoren â†’ Geometrie
 */
export class CubeBuilder {

  /**
   * center: { x, y, z }
   * size: KantenlÃ¤nge
   */
  static build(center = { x: 0, y: 0, z: 0 }, size = 2) {

    const h = size / 2;

    // 8 Eckpunkte
    const v = {
      lbf: [-h, -h, -h],
      rbf: [ h, -h, -h],
      ltf: [-h,  h, -h],
      rtf: [ h,  h, -h],

      lbb: [-h, -h,  h],
      rbb: [ h, -h,  h],
      ltb: [-h,  h,  h],
      rtb: [ h,  h,  h]
    };

    // Kanten
    const edges = [
      v.lbf, v.rbf,  v.rbf, v.rtf,  v.rtf, v.ltf,  v.ltf, v.lbf,
      v.lbb, v.rbb,  v.rbb, v.rtb,  v.rtb, v.ltb,  v.ltb, v.lbb,
      v.lbf, v.lbb,  v.rbf, v.rbb,  v.ltf, v.ltb,  v.rtf, v.rtb
    ];

    const positions = [];
    for (const p of edges) {
      positions.push(
        p[0] + center.x,
        p[1] + center.y,
        p[2] + center.z
      );
    }

    // âœ… WICHTIG: vec4-Farben
    const colors = [];
    for (let i = 0; i < positions.length / 3; i++) {
      colors.push(0.2, 0.2, 0.2, 1.0);
    }

    return {
      primitives: "LINES",
      num_dim: 3,
      num_color: 4,          // â† DAS war der Killer
      num_vertices: positions.length / 3,
      positions,
      colors
    };
  }
}

# FILE C:\Homepage\math-education-v5\src\builders\CubeWireframeBuilder.js

// src/builders/CubeWireframeBuilder.js
"use strict";

/**
 * Erzeugt einen drahtgitter-WÃ¼rfel (Wireframe)
 * symmetrisch um den Ursprung.
 *
 * Der WÃ¼rfel dient als visuelle Raumreferenz.
 */
export class CubeWireframeBuilder {

	static build(size = 1) {

		const s = size;

		// 8 Ecken des WÃ¼rfels
		const v = [
		[-s, -s, -s],
		[ s, -s, -s],
		[ s,  s, -s],
		[-s,  s, -s],
		[-s, -s,  s],
		[ s, -s,  s],
		[ s,  s,  s],
		[-s,  s,  s],
		];

		// Kanten (jeweils 2 Eckpunkte)
		const edges = [
			[0,1],[1,2],[2,3],[3,0], // unten
			[4,5],[5,6],[6,7],[7,4], // oben
			[0,4],[1,5],[2,6],[3,7]  // vertikal
		];

		const positions = [];
		const colors = [];

		for (const [a, b] of edges) {
			positions.push(...v[a], ...v[b]);

			// Grau, leicht transparent
			colors.push(
				0.7, 0.7, 0.7, 1,
				0.7, 0.7, 0.7, 1
			);
		}

		return {
			primitives: "LINES",
			num_dim: 3,
			num_color: 4,
			num_vertices: positions.length / 3,
			positions,
			colors
		};
	}
}

# FILE C:\Homepage\math-education-v5\src\builders\VectorBuilder.js

// src/builders/VectorBuilder.js
export class VectorBuilder {

  static build(vector, options = {}) {

    const { color = [0, 0, 0, 1], scale = 1 } = options;

    const positions = [
      0, 0, 0,
      vector.x * scale,
      vector.y * scale,
      vector.z * scale
    ];

    const colors = [
      ...color,
      ...color
    ];

    return {
      primitives: "LINES",
      num_dim: 3,
      num_color: 4,
      num_vertices: 2,
      positions,
      colors
    };
  }
}

# FILE C:\Homepage\math-education-v5\src\controls\CameraController.js

// src/controls/CameraController.js
export class CameraController {
    constructor(camera, onChange) {
        this.camera = camera;
        this.onChange = onChange;

        window.addEventListener("keydown", this.handleKey.bind(this));
    }

    handleKey(e) {
        switch (e.key) {
            case "ArrowLeft":
                this.camera.angleY -= 5;
                break;
            case "ArrowRight":
                this.camera.angleY += 5;
                break;
            case "ArrowUp":
                this.camera.angleX -= 5;
                break;
            case "ArrowDown":
                this.camera.angleX += 5;
                break;
            default:
                return;
        }

        this.onChange(); // z.B. scene.render()
    }
}

# FILE C:\Homepage\math-education-v5\src\experiments\loadExperiment.js

// src/experiments/loadExperiment.js
"use strict";

export function loadExperiment(name) {
    switch (name) {
        case "basisChange":
        return import("./"+name+"/index.js").then((m) => m.default);
        break
        case "linearMap":
        return import("./"+name+"/index.js").then((m) => m.default);
        break
        default:
        return Promise.reject(new Error("Unbekanntes Experiment: " + name));
    }
}

# FILE C:\Homepage\math-education-v5\src\experiments\basisChange\index.js

// src/experiments/basisChange/index.js
"use strict";

import { setup } from "./setup.js";
import { run } from "./run.js";

export default { setup, run };

# FILE C:\Homepage\math-education-v5\src\experiments\basisChange\run.js

// src/experiments/basisChange/run.js
"use strict";

export function run(scene, state) {
  	// this.setup() kommt aus index.js (default export {setup, run})
  	// Weil nach const experiment = await loadExperiment("basisChange")
	//
  	// ist experiment === 	{
  	//                        	setup: [Function],
  	// 							run:   [Function]
	// 						}
	//
	// und wenn experiment.run(..) aufruft dann ist this = experiment innerhalb von der funktion run(..).
	// Das ist dynamische bindung von this, sehr mÃ¼hsam in js!
	const data = this.setup();

	// WICHTIG: Experiment setzt NUR Bedeutung (State), nicht Rendering.
	state.setBasisA(data.basisA);
	state.setBasisB(data.basisB);
	state.setVector(data.vector);

	// Kein scene.render() hier!
	// Das passiert automatisch ueber state.notify() -> Listener.
}

# FILE C:\Homepage\math-education-v5\src\experiments\basisChange\setup.js

// src/experiments/basisChange/setup.js
"use strict";

import { Basis } from "../../math/Basis.js";
import { Vector3 } from "../../math/Vector3.js";

export function setup() {
  const basisA = Basis.standard();

  // schiefe Basis (nur Beispiel)
  const ANZ_GRAD = -20;
  const basisB = Basis.standard().rotateZ( (ANZ_GRAD / 180) * Math.PI); // ANZ_GRAD drehen

  const vector = new Vector3(7, 4, 0);

  return { basisA, basisB, vector };
}

# FILE C:\Homepage\math-education-v5\src\experiments\LinearMap\index.js

// src/experiments/LinearMap/index.js

import { setup } from "./setup.js";
import { run } from "./run.js";

export default { setup, run };

# FILE C:\Homepage\math-education-v5\src\experiments\LinearMap\run.js

// src/experiments/LinearMap/run.js
"use strict";

export function run(state, linearMapMatrix) {

    const data = this.setup(linearMapMatrix);

    // NUR Bedeutung setzen
    state.setBasisA(data.basisA);
    state.setBasisB(data.basisB);

    state.setVector(data.vector);
    state.setMatrix(data.linearMapMatrix);
    state.setResultVector(data.result);
}

# FILE C:\Homepage\math-education-v5\src\experiments\LinearMap\setup.js

// src/experiments/LinearMap/run.js
"use strict";

import { Basis } from "../../math/Basis.js";
import { Vector3 } from "../../math/Vector3.js";
import { Matrix3 } from "../../math/Matrix3.js";

export function setup(linearMapMatrix) {

    const basisA = Basis.standard();

    const basisB = Basis.standard().transform(linearMapMatrix); // ANZ_GRAD drehen

    const vector = new Vector3(3, 4, 0);

    const result = linearMapMatrix.multiplyVector(vector);

    return {
        basisA,
        basisB,
        vector,
        linearMapMatrix,
        result
    };
}

# FILE C:\Homepage\math-education-v5\src\geometry\Geometry.js

export class Geometry {
	constructor({ positions, colors, primitiveType }) {
		this.positions = positions;
		this.colors = colors;
		this.primitiveType = primitiveType;
		this.vertexCount = positions.length / 3;
	}
}

# FILE C:\Homepage\math-education-v5\src\gl\createProgram.js

// src/gl/createProgram.js
import { createShader } from "./createShader.js";

export function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    const msg = gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    throw new Error(msg);
  }

  return {
    program,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(program, "aVertexPosition"),
      vertexColor: gl.getAttribLocation(program, "aVertexColor"),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(program, "uProjectionMatrix"),
      modelViewMatrix: gl.getUniformLocation(program, "uModelViewMatrix"),
    }
  };
}

# FILE C:\Homepage\math-education-v5\src\loaders\GeometryLoader.js

/*
Warum heisst es GeometryLoader.js, es tut doch nur json laden und kein Geometrie-Objekt?

JSON ist Data pur.
Unsere Geometry ist Data pur.
Also sind sie konzeptionell dasselbe.

*/

export async function loadGeometry(url) {
	const res = await fetch(url);
	if (!res.ok) {
		throw new Error("Failed to load geometry: " + url);
	}
	return await res.json();
}

# FILE C:\Homepage\math-education-v5\src\math\Basis.js

import { Matrix3 } from "./Matrix3.js";
import { Vector3 } from "./Vector3.js";

export class Basis {
    constructor(e1, e2, e3) {
        this.e1 = e1;
        this.e2 = e2;
        this.e3 = e3;
    }

    toMatrix() {
        return new Matrix3([
            [this.e1.x, this.e2.x, this.e3.x],
            [this.e1.y, this.e2.y, this.e3.y],
            [this.e1.z, this.e2.z, this.e3.z],
        ]);
    }

    // ------------------------
    // Basis aus Matrix erzeugen
    // (Spalten der Matrix = Basisvektoren)
    // ------------------------
    static fromMatrix(matrix) {
        const m = matrix.m;

        return new Basis(
            new Vector3(m[0][0], m[1][0], m[2][0]), // erste Spalte
            new Vector3(m[0][1], m[1][1], m[2][1]), // zweite Spalte
            new Vector3(m[0][2], m[1][2], m[2][2])  // dritte Spalte
        );
    }

    static standard() {
        return new Basis(
            new Vector3(1,0,0),
            new Vector3(0,1,0),
            new Vector3(0,0,1)
        );
    }

    // ------------------------
    // Basis mit Matrix transformieren
    // (aktive lineare Abbildung)
    // ------------------------
    transform(matrix) {
        return new Basis(
            matrix.multiplyVector(this.e1),
            matrix.multiplyVector(this.e2),
            matrix.multiplyVector(this.e3)
        );
    }

    // ------------------------
    // Rotation um X-Achse
    // ------------------------
    rotateX(angleRad) {
        const c = Math.cos(angleRad);
        const s = Math.sin(angleRad);

        const rot = (v) =>
        new Vector3(
            v.x,
            c * v.y - s * v.z,
            s * v.y + c * v.z
        );

        return new Basis(
            rot(this.e1),
            rot(this.e2),
            rot(this.e3)
        );
    }

    // ------------------------
    // Rotation um Y-Achse
    // ------------------------
    rotateY(angleRad) {
        const c = Math.cos(angleRad);
        const s = Math.sin(angleRad);

        const rot = (v) =>
        new Vector3(
            c * v.x + s * v.z,
            v.y,
            -s * v.x + c * v.z
        );

        return new Basis(
            rot(this.e1),
            rot(this.e2),
            rot(this.e3)
        );
    }

    // ------------------------
    // Rotation um Z-Achse
    // ------------------------
    rotateZ(angleRad) {
        const c = Math.cos(angleRad);
        const s = Math.sin(angleRad);

        const rot = (v) =>
            new Vector3(
                c * v.x - s * v.y,
                s * v.x + c * v.y,
                v.z
            );

        return new Basis(
            rot(this.e1),
            rot(this.e2),
            rot(this.e3)
        );
    }
}

# FILE C:\Homepage\math-education-v5\src\render\Camera.js

// render/Camera.js
import { WorldConfig } from "../config.js";
import * as mat4 from "../math/mat4.js";
import { rad } from "../math/LenearAlgebra.js";

class Camera {
    constructor() {
        this.angleX = 0;
        this.angleY = 0;
        this.distance = WorldConfig.EXTENT * 6;
    }

    getViewMatrix() {
        const viewMatrix = mat4.create();

        mat4.translate(viewMatrix, viewMatrix, [0, 0, -this.distance]);
        mat4.rotate(viewMatrix, viewMatrix, rad(this.angleX), [1, 0, 0]);
        mat4.rotate(viewMatrix, viewMatrix, rad(this.angleY), [0, 1, 0]);

        return viewMatrix;
    }
}

export { Camera };

# FILE C:\Homepage\math-education-v5\src\render\Drawable.js

/**
 * CPU (JavaScript)
â”‚
â”‚  Geometry (positions, colors)
â”‚
â”‚  gl.bufferData(...)  â† KOPIE
â”‚
â–¼
GPU-Speicher (Buffer)
â”‚
â”‚  Attribute zeigen in Buffer hinein
â”‚
â–¼
Vertex-Shader
â”‚
â”‚  + Uniforms (global)
â”‚
â–¼
gl_Position

GPU / WEBGL â€“ KONZEPTUELLE ÃœBERSICHT
==================================

Dieses Projekt benutzt WebGL bewusst didaktisch.
Ziel ist zu verstehen:
- welche Daten WO liegen
- wann sie gesetzt werden
- wie oft sie sich Ã¤ndern
- wer (CPU oder GPU) sie benutzt

--------------------------------------------------
1) ZWEI GETRENNTE WELTEN
--------------------------------------------------

CPU (JavaScript)
- fÃ¼hrt den Code aus
- berechnet Mathematik
- lÃ¤dt Daten
- entscheidet, WAS gezeichnet wird

GPU (Grafikkarte)
- fÃ¼hrt Shader aus
- verarbeitet Millionen Vertices / Pixel parallel
- kennt KEINE JavaScript-Objekte
- sieht nur rohe Zahlen

CPU und GPU haben getrennten Speicher.
Daten mÃ¼ssen explizit von CPU â†’ GPU kopiert werden.

--------------------------------------------------
2) GPU-SPEICHER: BUFFER
--------------------------------------------------

Buffer sind Speicherbereiche auf der GPU.

In diesem Projekt verwenden wir hauptsÃ¤chlich:

- ARRAY_BUFFER
  â†’ speichert Vertex-Daten
  â†’ z.B. Positionen, Farben, Normalen

Beispiel:
gl.createBuffer()
gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)

WICHTIG:
- bufferData kopiert Daten EINMAL von CPU â†’ GPU
- spÃ¤tere Ã„nderungen am JavaScript-Array haben KEINE Wirkung
- Buffer bleiben auf der GPU, bis sie gelÃ¶scht werden

Lebensdauer:
- meist: beim Erzeugen eines Drawable
- bleibt Ã¼ber viele Frames bestehen

--------------------------------------------------
3) ATTRIBUTE (vertex attributes)
--------------------------------------------------

Attribute sind GPU-Variablen,
die sich PRO VERTEX unterscheiden.

Typische Attribute:
- Position eines Vertex
- Farbe eines Vertex
- Normalenvektor

Im Vertex-Shader:
attribute vec3 aVertexPosition;
attribute vec3 aVertexColor;

Eigenschaften:
- ein Wert pro Vertex
- Werte kommen aus Buffern
- GPU iteriert automatisch Ã¼ber alle Vertices

Verbindung Buffer â†’ Attribut:
gl.bindBuffer(...)
gl.vertexAttribPointer(...)
gl.enableVertexAttribArray(...)

Lebensdauer:
- Definition: einmal beim Setup
- Nutzung: bei jedem Draw-Call
- Wert: pro Vertex unterschiedlich

--------------------------------------------------
4) UNIFORMS
--------------------------------------------------

Uniforms sind GPU-Variablen,
die fÃ¼r ALLE Vertices und Pixel gleich sind.

Typische Uniforms:
- Projektionsmatrix
- View-Matrix
- Zeit
- Farbe
- Lichtparameter

Im Shader:
uniform mat4 uProjectionMatrix;
uniform mat4 uModelViewMatrix;

Eigenschaften:
- ein Wert pro Draw-Call
- gleich fÃ¼r alle Vertices
- wird von der CPU gesetzt

Setzen in JavaScript:
gl.uniformMatrix4fv(...)
gl.uniform1f(...)
gl.uniform3fv(...)

Lebensdauer:
- meist: pro Frame oder pro Objekt
- Werte bleiben gÃ¼ltig, bis sie Ã¼berschrieben werden

--------------------------------------------------
5) VERTEX-SHADER
--------------------------------------------------

Der Vertex-Shader lÃ¤uft:

- EINMAL PRO VERTEX
- vollstÃ¤ndig auf der GPU
- parallel fÃ¼r alle Vertices

Aufgaben:
- liest Attribute (Position, Farbe, ...)
- benutzt Uniforms (Matrizen, Parameter)
- berechnet gl_Position

WICHTIG:
- Vertex-Shader kennt KEINE anderen Vertices
- kein globaler Zustand
- keine Schleifen Ã¼ber andere Vertices

--------------------------------------------------
6) FRAGMENT-SHADER
--------------------------------------------------

Der Fragment-Shader lÃ¤uft:

- EINMAL PRO PIXEL (Fragment)
- nach der Rasterisierung
- oft millionenfach pro Frame

Aufgaben:
- berechnet die Farbe eines Pixels
- kann Uniforms lesen
- kann interpolierte Werte aus dem Vertex-Shader lesen

WICHTIG:
- Fragment-Shader kennt KEINE Vertices
- kennt nur den aktuellen Pixel

--------------------------------------------------
7) LEBENSDAUER-ÃœBERSICHT
--------------------------------------------------

Pro Anwendung (einmal):
- Shader kompilieren
- Programme erstellen

Pro Objekt (einmal):
- Geometry erzeugen
- Buffer anlegen
- Drawable erstellen

Pro Frame:
- Clear Screen
- Uniforms setzen (z.B. View/Projection)
- drawArrays aufrufen

Pro Vertex:
- Vertex-Shader ausfÃ¼hren

Pro Pixel:
- Fragment-Shader ausfÃ¼hren

--------------------------------------------------
8) WICHTIGE MERKSÃ„TZE
--------------------------------------------------

- Buffer = GPU-Speicher
- Attribute = Daten pro Vertex
- Uniforms = Daten fÃ¼r alle Vertices
- Vertex-Shader = pro Vertex
- Fragment-Shader = pro Pixel
- GPU rechnet, CPU denkt

--------------------------------------------------
9) DIDAKTISCHE ENTSCHEIDUNG DIESES PROJEKTS
--------------------------------------------------

- Mathematik findet auf der CPU statt
- Geometrie wird explizit berechnet
- Shader sind bewusst "dumm"
- Keine versteckte Logik in der GPU (Optimierungen siehe unten)

Ziel:
Verstehen, nicht optimieren.

 *
 *

 * Drawable
 * --------
 * Ein Drawable ist die GPU-ReprÃ¤sentation von Geometry-DATEN.
 *
 * WICHTIG:
 * - Drawable kennt KEINE Mathematik
 * - Drawable kennt KEINE Bedeutung
 * - Drawable kennt KEINE Kamera-Semantik
 *
 * Aufgabe:
 *   CPU-Daten  â†’ GPU-Speicher
 *   GPU-Speicher â†’ drawArrays

 *

 * Ein Drawable ist die BrÃ¼cke zwischen CPU (JavaScript)
 * und GPU (WebGL).
 *
 * Es nimmt reine GEOMETRIE-DATEN (Zahlen)
 * und lÃ¤dt sie in den Grafikspeicher.
 *
 * Drawable:
 * - macht KEINE Mathematik
 * - interpretiert KEINE Bedeutung
 * - reicht Daten nur weiter
 */

"use strict";

class Drawable {

    /**
     * Konstruktor
     *
     * gl          â†’ Zugriff auf GPU
     * programInfo â†’ Shader + Locations (Uniforms, Attributes)
     * geometry    â†’ reine Daten (CPU-Speicher)
     */
    constructor(gl, programInfo, geometry) {

        // WebGL-Kontext (unsere Verbindung zur GPU)
        this.gl = gl;

        // EnthÃ¤lt:
        // - Shader-Programm
        // - wo Uniforms liegen
        // - wo Attribute liegen
        this.programInfo = programInfo;

        // Geometry lebt im CPU-Speicher (JavaScript-Objekt)
        this.geometry = geometry;

        // Referenzen auf GPU-Speicher (noch leer)
        this.vertexBuffer = null;
        this.colorBuffer = null;

        // Welches primitive wird gezeichnet? (LINES, TRIANGLES, ...)
        const primitiveName = geometry.primitives?.toUpperCase();
        this.primitiveType =
            gl[primitiveName] !== undefined
                ? gl[primitiveName]
                : gl.TRIANGLES;

        // Wie viele Vertices sollen gezeichnet werden?
        // Entweder explizit angegeben oder aus den Daten berechnet
        this.vertexCount =
            geometry.num_vertices ??
            (geometry.positions.length / geometry.num_dim);

        // JETZT: Daten von CPU â†’ GPU kopieren
        this.initBuffers();
    }

    /**
     * initBuffers
     * -----------
     * Dieser Schritt ist extrem wichtig:
     *
     * Hier verlassen die Daten endgÃ¼ltig JavaScript
     * und landen im GPU-Speicher.
     *
     * Danach:
     * - JavaScript kann die Daten Ã¤ndern,
     *   aber die GPU merkt davon NICHTS.
     */
    initBuffers() {
        const gl = this.gl;

        // ===============================
        // POSITIONS-BUFFER
        // ===============================

        // 1) GPU-Speicher anlegen
        this.vertexBuffer = gl.createBuffer();

        // 2) Sagen: dieser Buffer ist jetzt ein ARRAY_BUFFER
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        // 3) CPU â†’ GPU Kopie
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(this.geometry.positions),
            gl.STATIC_DRAW
        );

        // ===============================
        // COLOR-BUFFER (optional)
        // ===============================
        if (
            this.geometry.colors &&
            this.geometry.colors.length ===
                this.vertexCount * this.geometry.num_color
        ) {
            this.colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);

            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(this.geometry.colors),
                gl.STATIC_DRAW
            );
        }
    }

    /**
     * draw
     * ----
     * Dieser Aufruf zeichnet das Objekt.
     *
     * WICHTIG:
     * - draw() lÃ¤uft PRO FRAME
     * - Buffer liegen bereits auf der GPU
     * - jetzt werden nur noch ZEIGER gesetzt
     */
    draw(projectionMatrix, viewMatrix) {
        const gl = this.gl;
        const prog = this.programInfo;

        // ===============================
        // UNIFORMS
        // ===============================
        // Uniforms sind globale Werte:
        // - gleich fÃ¼r ALLE Vertices
        // - werden einmal pro Draw gesetzt

        gl.uniformMatrix4fv(
            prog.uniformLocations.projectionMatrix,
            false,
            projectionMatrix
        );

        gl.uniformMatrix4fv(
            prog.uniformLocations.modelViewMatrix,
            false,
            viewMatrix
        );

        // ===============================
        // POSITION-ATTRIBUTE
        // ===============================
        // Attribute sind PRO VERTEX unterschiedlich

        // 1) richtigen Buffer auswÃ¤hlen
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);

        // 2) erklÃ¤ren, wie die Daten gelesen werden sollen
        gl.vertexAttribPointer(
            prog.attribLocations.vertexPosition,
            this.geometry.num_dim,   // z.B. vec3
            gl.FLOAT,
            false,
            0,
            0
        );

        // 3) Attribut aktivieren
        gl.enableVertexAttribArray(
            prog.attribLocations.vertexPosition
        );

        // ===============================
        // COLOR-ATTRIBUTE
        // ===============================
        if (this.colorBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.vertexAttribPointer(
                prog.attribLocations.vertexColor,
                this.geometry.num_color,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(
                prog.attribLocations.vertexColor
            );
        } else {
            // Keine Farben pro Vertex:
            // â†’ eine konstante Farbe fÃ¼r alle Vertices
            gl.disableVertexAttribArray(
                prog.attribLocations.vertexColor
            );
            gl.vertexAttrib4fv(
                prog.attribLocations.vertexColor,
                this.geometry.colors
            );
        }

        // ===============================
        // DRAW CALL
        // ===============================
        // JETZT arbeitet die GPU:
        // - Vertex-Shader wird pro Vertex ausgefÃ¼hrt
        // - Fragment-Shader pro Pixel

        gl.drawArrays(
            this.primitiveType,
            0,
            this.vertexCount
        );
    }
}

export { Drawable };

/*
Konkrete Performance-Gewinne (realistisch)

MaÃŸnahme	                                    Gewinn

Buffer nur einmal erstellen	                    â­â­

Draw Calls reduzieren	                        â­â­â­

CPU â†’ GPU Mathe verschieben	                    â­â­â­â­

Instancing	                                    â­â­â­â­â­

*/

# FILE C:\Homepage\math-education-v5\src\render\Projection.js

"use strict";

/*
=====================================================
PROJECTION.JS â€“ DARSTELLUNGS-MATHE (KAMERA / SICHT)
=====================================================

WICHTIGER KONTEXT (DIDAKTISCH):

Dieses Modul gehÃ¶rt bewusst NICHT in /math.

Warum?
- Die Mathematik hier beschreibt KEINE objektive Welt
- Sie beschreibt, wie eine KAMERA die Welt sieht
- Ohne Rendering (Bildschirm, Sichtkegel, Clipping)
  ergibt diese Mathematik keinen Sinn

Merksatz:
â†’ Projektion ist keine Welt-Mathematik
â†’ Projektion ist Darstellungs-Mathematik

-----------------------------------------------------
Pipeline-Kontext:

Weltkoordinaten
   â†“ (View-Matrix: Welt â†’ Kamera)
Kamerakoordinaten
   â†“ (Projektionsmatrix: Kamera â†’ Clip Space)
Clip Space (-1 .. 1)
   â†“ (Viewport)
Bildschirm

Dieses Modul liefert AUSSCHLIESSLICH:
â†’ Kamerakoordinaten â†’ Clip Space
=====================================================
*/

// ===================================================
// PERSPEKTIVISCHE PROJEKTION
// ===================================================
/*
Dies ist die klassische Perspective Projection Matrix.

Was sie leistet:

- Alle Punkte im Sichtkegel (Frustum) der Kamera
  werden in den normierten Raum [-1, 1] abgebildet
- Das Clipping-Volume ist ein WÃ¼rfel von -1 bis +1
- Das Aspect Ratio (Breite / HÃ¶he) wird korrekt berÃ¼cksichtigt
- z-Werte werden ebenfalls in [-1, 1] abgebildet
  (fÃ¼r Tiefentest & Clipping)

WICHTIG:
Diese Matrix geht davon aus, dass:
- die Kamera im Ursprung sitzt
- die Kamera entlang der -Z-Achse schaut
- die View-Matrix diese Voraussetzungen bereits hergestellt hat

Die ZENTRIERUNG der Kamera (Apex des Frustums)
passiert NICHT hier, sondern in der View-Matrix!

Diese Funktion ist also NUR fÃ¼r:
â†’ zentrierte Kamera
â†’ standardisierte Kamerakoordinaten
*/

function createPerspectiveProjection(gl) {

    // ------------------------------------------------
    // Kamera-Parameter (bewusst hier, nicht abstrahiert)
    // ------------------------------------------------

    // Field of View (vertikal), in Radiant
    const fov = 20 * (Math.PI / 180);

    // Aspect Ratio des Bildschirms
    // â†’ DAS ist DarstellungsabhÃ¤ngigkeit
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

    // Near- und Far-Plane des Frustums
    const zNear = 0.3;
    const zFar  = 100.0;

    // ------------------------------------------------
    // Mathematische Vorbereitung
    // ------------------------------------------------

    const angle = fov / 2.0;

    /*
    ACHTUNG (WICHTIG UND DIDAKTISCH):

    Die Matrix ist im COLUMN-MAJOR Format gespeichert,
    wie es WebGL (und OpenGL) erwarten.

    Das bedeutet:
    - Die "Spalten" der mathematischen Matrix
      stehen hier untereinander im Array
    - Beim Lesen wirkt die Matrix "transponiert"

    Das ist KEIN Denkfehler, sondern ein Speicherlayout-Thema.
    */

    // Dies ist die komplette Projektions-Matrix (Perspective-Projextion-Matrix). Alle Koordinaten der Vertices im Frustum werden richtig
    // in den Bereich von -1 zu 1 projeziert. Auch die Tatsache, dass aspect ration nicht gleich 1 ist wird beachtet durch diese Matrix.
    // Auch die z-Koordinaten werden zwischen -1 und 1 projeziert (fÃ¼r allfÃ¤lliges weg clippen oder so).
    // Anfangs dachte ich, dass was fehlt, z.B. die Zentrierung von apex (Kamera) oder so. Aber diese Funktion ist nur fÃ¼r fÃ¼r zentrierte
    // Kamera zugelassen.
    // Dann dachte ich auch, dass ja das Ganze auf ein clipping volume projeziert werden muss (clipping volume: WÃ¼rfel von -1 zu 1) und dass
    // das dem Aspect Ratio wiederspricht, weil aspect ratio kann auch nicht gleich 1 sein. Aber es wird in den Formeln ebenfalls
    // beachtet wie ich raus fand.
    const projectionMatrix = [

        // Spalte 0
        1.0 / (aspect * Math.tan(angle)),  0.0,  0.0,   0.0,

        // Spalte 1
        0.0,  1.0 / Math.tan(angle),        0.0,   0.0,

        // Spalte 2
        0.0,  0.0,  (zFar + zNear) / (zNear - zFar),  -1.0,

        // Spalte 3
        0.0,  0.0,  (2 * zFar * zNear) / (zNear - zFar),  0.0
    ];

    return projectionMatrix;
}

// ===================================================
// ORTHOGRAFISCHE PROJEKTION
// ===================================================
/*
Orthografische Projektion:

- KEINE Perspektive
- Parallele Kanten bleiben parallel
- Keine Tiefenverzerrung
- Oft verwendet fÃ¼r:
  - CAD
  - technische Zeichnungen
  - UI-Overlays
  - Debug-Ansichten

Hier wird ein Quader direkt
auf den Clip-WÃ¼rfel [-1,1] abgebildet.
*/

function createOrthographicProjection(left, right, bottom, top, zNear, zFar) {

    const orthographicMatrix = [

        // Spalte 0
        2.0 / (right - left),  0.0,  0.0,  0.0,

        // Spalte 1
        0.0,  2.0 / (top - bottom),  0.0,  0.0,

        // Spalte 2
        0.0,  0.0,  -2.0 / (zFar - zNear),  0.0,

        // Spalte 3
        -(right + left) / (right - left),
        -(top + bottom) / (top - bottom),
        -(zFar + zNear) / (zFar - zNear),
        1.0
    ];

    return orthographicMatrix;
}

// ===================================================
// FRUSTUM-PROJEKTION (ALLGEMEIN)
// ===================================================
/*
Allgemeine Frustum-Projektion:

- Left / Right / Top / Bottom kÃ¶nnen unterschiedlich sein
- Kamera muss evtl. NICHT zentriert sein
- Grundlage fÃ¼r Off-Center-Projektionen
- Stereo-Rendering
- Shadow Maps

HINWEIS:
Falls das Frustum nicht symmetrisch ist,
muss zusÃ¤tzlich eine View-Transformation erfolgen,
die den Apex (Kamera) ins Koordinatenzentrum verschiebt.
*/

function createFrustumProjection(left, right, bottom, top, zNear, zFar) {
    // Diese Funktion macht geanu das Gleiche wie createPerspectiveProjection(..) einfach mit anderen Argumenten.
	// Left und Right mÃ¼ssen gleich lang sein. Und auch top, bottom aber nur hier, im Allgemeinen mÃ¼sste diese Funktion das auch beachten.
	// Falls die Kamera nicht im Zentrum steht (d.h. -left != right oder -bottom != top) dann mÃ¼sste man die Funktion noch fertig schreiben.
	// In einem solchen Fall mÃ¼sste man dann noch die Zentrierung der Kamera ausfÃ¼hren (Translate the apex of the frustum to the origin).
	// Die zentrierung der Kamera to the origin (apex ist die Kamera) kann man sich so vorstellen: Ist as apex nach rechts (x-Achse) v
    // erschoben, so schiebe man das Koordinatensystem auch nach Rechts Richtung der x-Achse so dass der Koordinaten-Ursprung auf das
    // Apex zu liegen kommt. Als Folge verschieben sich die Koordinaten der einzelnen Vertices nach "Links" der x-Achse nach, also ins Minus.
    // Das Gleiche tue man natÃ¼rlich fÃ¼r Y-Achse falls nÃ¶tig.
	// Das "nach Rechts" kÃ¶nnte natÃ¼rlich auch "nach Links" sein, das war nur ein Beispiel o.B.d.A. sozusagen.
    return [

        // Spalte 0
        (2 * zNear) / (right - left),  0.0,  0.0,  0.0,

        // Spalte 1
        0.0,  (2 * zNear) / (top - bottom),  0.0,  0.0,

        // Spalte 2
        (right + left) / (right - left),
        (top + bottom) / (top - bottom),
        -(zFar + zNear) / (zFar - zNear),
        -1.0,

        // Spalte 3
        0.0,  0.0,  -(2 * zFar * zNear) / (zFar - zNear),  0.0
    ];
}

// ===================================================
// EXPORTS
// ===================================================

export {
    createPerspectiveProjection,
    createOrthographicProjection,
    createFrustumProjection
};

# FILE C:\Homepage\math-education-v5\src\render\Scene.js

// src/render/Scene.js
"use strict";

import { Drawable } from "./Drawable.js";
import { Camera } from "./Camera.js";
import { CameraController } from "../controls/CameraController.js";
import { createPerspectiveProjection } from "./Projection.js";

/**
 * Scene
 * -----
 * Orchestriert das Rendern.
 *
 * Verantwortung:
 * - besitzt den WebGL-Kontext
 * - besitzt das Shader-Programm (programInfo)
 * - hÃ¤lt Drawables (GPU-ReprÃ¤sentationen von Geometrie)
 * - benutzt Kamera (View-Matrix)
 * - benutzt Projektion (Projection-Matrix)
 *
 * Bewusst NICHT hier:
 * - Shader laden
 * - Shader kompilieren
 * - fetch / Dateipfade
 * - Geometrie-Erzeugung
 * - Lineare Algebra (auÃŸer Ãœbergabe von Matrizen)
 */
class Scene {
    constructor(canvas, gl, programInfo, geometries) {

        // -------------------------------------------------------------------------
        // Kontext
        // -------------------------------------------------------------------------
        this.canvas = canvas;
        this.gl = gl;

        // -------------------------------------------------------------------------
        // Shader-Programm (fertig Ã¼bergeben!)
        // -------------------------------------------------------------------------
        this.programInfo = programInfo;
        this.gl.useProgram(this.programInfo.program);

        // -------------------------------------------------------------------------
        // Kamera (View)
        // -------------------------------------------------------------------------
        this.camera = new Camera();

        // -------------------------------------------------------------------------
        // Drawables (GPU-Objekte)
        // -------------------------------------------------------------------------
        this.drawables = [];

        if(geometries) {
            for (const key of Object.keys(geometries)) {
                this.drawables.push(
                    new Drawable(this.gl, this.programInfo, geometries[key])
                );
            }
        }

        this.controller = new CameraController(
            this.camera,
            () => this.render()
        );
    }

    // -------------------------------------------------------------------------
    // Add Drawables (GPU-Objekte)
    // -------------------------------------------------------------------------
    addGeometry(geometrie) {
        this.drawables.push(new Drawable(this.gl, this.programInfo, geometrie));
    }

    // ---------------------------------------------------------------------------
    // Render
    // ---------------------------------------------------------------------------
    render() {
        const gl = this.gl;

        // gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        // Projektion (Frustum â†’ Clip Space)
        const projectionMatrix = createPerspectiveProjection(gl);

        // View (Welt â†’ Kamera)
        const viewMatrix = this.camera.getViewMatrix();

        // Clear
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Draw Calls
        for (const drawable of this.drawables) {
            drawable.draw(projectionMatrix, viewMatrix);
        }
    }

    clear() {
        // WICHTIG: logische Szene leeren (Drawables entfernen)
        this.drawables = [];

        // Bildschirm leeren (nur visuell)
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    }
}

export { Scene };

# FILE C:\Homepage\math-education-v5\src\state\MathState.js

// src/state/MathState.js
"use strict";

import { Basis } from "../math/Basis.js";

export class MathState {
    constructor() {
        this.basisA = null;
        this.basisB = null;
        this.vector = null;
        this.matrix = null;
        this.resultVector = null;

        this.listeners = [];
    }

    onChange(fn) {
        this.listeners.push(fn);
    }

    notify() {
        for (const fn of this.listeners) {
            fn(this);
        }
    }

    setBasisA(basis) {
        this.basisA = basis;
        this.notify();
    }

    setBasisB(basis) {
        this.basisB = basis;
        this.notify();
    }

    setVector(v) {
        this.vector = v;

        // ðŸ”¥ HIER die Abbildung
        if (this.matrix) {
            this.resultVector = this.matrix.multiplyVector(v);
        }

        this.notify();
    }

    setMatrix(m) {
        this.matrix = m;

        // ðŸ”¥ BasisB aktualisieren
        this.basisB = Basis.standard().transform(m);
        // oder:
        // this.basisB = Basis.fromMatrix(m);

        if (this.vector) {
            this.resultVector = m.multiplyVector(this.vector);
        }

        this.notify();
    }

    setResultVector(v) {
        this.resultVector = v;
        this.notify();
    }
}

# FILE C:\Homepage\math-education-v5\src\ui\LinearMapView.js

// src/ui/LinearMapView.js
"use strict";

import { Vector3 } from "../math/Vector3.js";
import { Matrix3 } from "../math/Matrix3.js";

function cell(value, editable, onChange) {
    if (!editable) {
        return `<div class="cell">${value.toFixed(2)}</div>`;
    }
    return `<input class="cell" type="number" step="0.1" value="${value}"
        data-hook="edit">`;
}

export function bindLinearMapView(state) {

    const mDiv = document.getElementById("matrixA");
    const vDiv = document.getElementById("vectorV");
    const rDiv = document.getElementById("vectorR");

    state.onChange((s) => {
        if (!s.matrix || !s.vector || !s.resultVector) return;

        const is2D =
            s.matrix.m[0][2] === 0 &&
            s.matrix.m[1][2] === 0 &&
            s.matrix.m[2][0] === 0 &&
            s.matrix.m[2][1] === 0 &&
            s.matrix.m[2][2] === 1 &&
            s.vector.z === 0;

        // ---------- MATRIX ----------
        mDiv.innerHTML = "";

        const rows = is2D ? 2 : 3;
        const cols = is2D ? 2 : 3;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {

                const inp = document.createElement("input");
                inp.className = "cell";
                inp.type = "number";
                inp.step = "0.1";
                inp.value = s.matrix.m[row][col];

                inp.oninput = () => {

                    // Deep copy der 2D-Matrix
                    const newM = s.matrix.m.map(r => [...r]);

                    newM[row][col] = parseFloat(inp.value);

                    state.setMatrix(new Matrix3(newM));
                };

                mDiv.appendChild(inp);
            }

            mDiv.appendChild(document.createElement("br"));
        }

       // ---------- VECTOR ----------
        vDiv.innerHTML = "";

        const dims = is2D ? ["x", "y"] : ["x", "y", "z"];

        const inputs = [];

        dims.forEach((k) => {
            const inp = document.createElement("input");
            inp.className = "cell";
            inp.type = "number";
            inp.step = "0.1";
            inp.value = s.vector[k];

            inputs.push(inp);

            inp.oninput = () => {
                const x = parseFloat(inputs[0].value);
                const y = parseFloat(inputs[1].value);
                const z = is2D ? 0 : parseFloat(inputs[2].value);

                state.setVector(new Vector3(x, y, z));
            };

            vDiv.appendChild(inp);
            vDiv.appendChild(document.createElement("br"));
        });

        // ---------- RESULT ----------
        rDiv.innerHTML = "";
        dims.forEach((k) => {
            const d = document.createElement("div");
            d.className = "cell";
            d.textContent = s.resultVector[k].toFixed(2);
            rDiv.appendChild(d);
            rDiv.appendChild(document.createElement("br"));
        });
    });
}

# PROJECT STRUCTURE

  Doku.odt
  GptKonvsAppArchtUndLinAbb.docx
  favicon.ico
  gpt_bundle.txt
  index.html
  server.py
  src/
    config.js
    app/
      index.js
    builders/
      CoordinateSystemBuilder.js
      CubeBuilder.js
      CubeWireframeBuilder.js
      VectorBuilder.js
    controls/
      CameraController.js
    experiments/
      loadExperiment.js
      basisChange/
        index.js
        run.js
        setup.js
      LinearMap/
        index.js
        run.js
        setup.js
    geometry/
      Geometry.js
    gl/
      createProgram.js
      createShader.js
    loaders/
      GeometryLoader.js
      loadText.js
    math/
      Basis.js
      LenearAlgebra.js
      Matrix3.js
      Vector3.js
      mat3.js
      mat4.js
    render/
      Camera.js
      Drawable.js
      Projection.js
      Scene.js
    shaders/
      fShaderCode.glsl
      vShaderCode.glsl
    state/
      MathState.js
    ui/
      Inspector.js
      LinearMapView.js
    utils/
      common.js
      graph2d.js
      index.js
      mat2.js
      mat2d.js
      quat.js
      quat2.js
      series.js
      vec2.js
      vec3.js
      vec4.js
      webgl-utils.js
      webgl-utils2.js
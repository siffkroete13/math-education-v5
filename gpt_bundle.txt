# FILE C:\Homepage\math-education-v5\src\app\index.js

/*
Mathematik
  â†“
Koordinatensystem / Vektoren / Basen
  â†“
GeometryBuilder (Ãœbersetzer)
  â†“
Geometry (positions, colors)
  â†“
Model_VOB (WebGL / GPU)
  â†“
Shader â†’ Pixel

ARCHITEKTURÃœBERSICHT â€“ MATHE / GEOMETRIE / RENDERING

Dieses Projekt ist bewusst didaktisch aufgebaut.
Ziel ist nicht â€žEngine-Benutzungâ€œ, sondern Verstehen:
Vektoren, Matrizen, RÃ¤ume, Projektion, Pixel.

---------------------------------------------------
1) MATHE (src/math)
---------------------------------------------------
Hier lebt die Bedeutung.

- Vektoren
- Basen
- lineare Abbildungen
- Basiswechsel (nicht zu verwechseln mit View-Matrix, die macht auch basiswechsel aber auf Infrastruktur-Ebene, das hier ist didaktisch)
- explizite Rechnungen

WICHTIG:
Mathe weiss NICHTS von WebGL, Shadern oder Rendering.
Mathe arbeitet nur mit Zahlen.

---------------------------------------------------
2) BUILDERS (src/builders)
---------------------------------------------------
Builder sind die BrÃ¼cke zwischen Mathe und Darstellung.

Aufgabe:
- nehmen mathematische Konzepte
- erzeugen daraus GEOMETRIE

Beispiele:
- CoordinateSystemBuilder â†’ Achsen aus Basis
- CubeBuilder â†’ WÃ¼rfel aus Vektoren
- VectorBuilder â†’ Pfeil aus Richtungsvektor

Builder:
- enthalten Mathematik
- erzeugen nur Daten
- geben Geometry-Objekte zurÃ¼ck

Builder machen KEIN Rendering.

---------------------------------------------------
3) GEOMETRY (Datenformat)
---------------------------------------------------
Geometry ist ein reines dummes Datenobjekt:

{
  positions: [...],
  colors: [...],
  primitives: "LINES",
  num_vertices: ...
}

Geometry:
- enthÃ¤lt KEINE Bedeutung
- enthÃ¤lt KEINE Transformation
- ist nur â€žwas gezeichnet werden sollâ€œ

---------------------------------------------------
4) RENDERING (src/render)
---------------------------------------------------
Rendering ist Darstellung, nicht Bedeutung.

- Drawable:
  - lÃ¤dt Geometry auf die GPU
  - fÃ¼hrt drawArrays aus
  - kennt keine Mathe-Bedeutung

- Scene:
  - orchestriert alles
  - kennt Kamera & Projektion
  - zeichnet Drawables

- Camera:
  - erzeugt View-Matrix

- Projection:
  - erzeugt Projektionsmatrix (Frustum)

Rendering rechnet NICHT an der Geometrie.
Es zeigt nur das Ergebnis.

---------------------------------------------------
5) SHADER (src/shaders)
---------------------------------------------------
Shader sind AusfÃ¼hrungsmaschinen.

- nehmen Matrizen
- wenden sie auf Vertices an
- keine Logik, keine Bedeutung

Shader sind absichtlich â€ždummâ€œ.

---------------------------------------------------
6) WICHTIGE DESIGNENTSCHEIDUNG
---------------------------------------------------
Dieses Projekt verzichtet bewusst auf Model-Matrizen (diejenigen die das Objekt selber drehen, nicht die Welt.)
in frÃ¼hen Phasen.

Stattdessen:
- Geometrie wird explizit transformiert
- jede Zahl ist sichtbar
- jede Rechnung nachvollziehbar

---------------------------------------------------
MERKSATZ
---------------------------------------------------
Mathe erklÃ¤rt.
Builder formen.
Rendering zeigt.
Shader fÃ¼hren aus.

*/

// src/app/index.js
"use strict";

import { WorldConfig } from "../config.js";
import { Matrix3 } from "../math/Matrix3.js";
import { MathState } from "../state/MathState.js";
import { loadText } from "../loaders/loadText.js";
import { createProgram } from "../gl/createProgram.js";
import { bindLinearMapView } from "../ui/LinearMapView.js";
import { CoordinateSystemBuilder } from "../builders/CoordinateSystemBuilder.js";
import { CubeWireframeBuilder } from "../builders/CubeWireframeBuilder.js";
import { VectorBuilder } from "../builders/VectorBuilder.js";
import { loadExperiment } from "../experiments/loadExperiment.js";
import { Scene } from "../render/Scene.js";

async function start() {

	// 1) Canvas + WebGL
	const canvas = document.querySelector("#meineWebGLCanvas");
	const gl = canvas.getContext("webgl");
	if (!gl) {
		alert("WebGL nicht verfÃ¼gbar");
		return;
	}

	// 2) Shader laden
	const [vShaderCode, fShaderCode] = await Promise.all([
		loadText("/src/shaders/vShaderCode.glsl"),
		loadText("/src/shaders/fShaderCode.glsl"),
	]);

	const programInfo = createProgram(gl, vShaderCode, fShaderCode);
	gl.useProgram(programInfo.program);

	// 3) Scene
	const scene = new Scene(
		canvas,
		gl,
		programInfo
		/*
		{
			axes: CoordinateSystemBuilder.build(basisA, 1.0),
			cube: CubeWireframeBuilder.build(1.0)
		}
		*/
	);

	// 4) State (Wahrheit)
	const state = new MathState();

	// 5) UI an State binden (nur lesen)
	bindLinearMapView(state);

	// Geometrie einmal erstellen
	this.cube = cube = scene.addGeometry(
		CubeWireframeBuilder.build(WorldConfig.EXTENT)
	);

	let vectorDrawable = null;
	let resultDrawable = null;

	// 6) Rendering an State binden (nur lesen)
	state.onChange((s) => {

		if (s.vector && !vectorDrawable) {
			vectorDrawable = scene.addGeometry(
				VectorBuilder.build(s.vector, { color: [1,0,0,1] })
			);
		}

		if (s.resultVector && !resultDrawable) {
			resultDrawable = scene.addGeometry(
				VectorBuilder.build(s.resultVector, { color: [0,1,0,1] })
			);
		}

		if (vectorDrawable) {
			vectorDrawable.updatePositions([
				0,0,0,
				s.vector.x,
				s.vector.y,
				s.vector.z
			]);
		}

		if (resultDrawable) {
			resultDrawable.updatePositions([
				0,0,0,
				s.resultVector.x,
				s.resultVector.y,
				s.resultVector.z
			]);
		}
	});

	// 7) Starten
	scene.start();
}

// DOM Ready
(function r(f) {
  	/in/.test(document.readyState) ? setTimeout(() => r(f), 9) : f();
})(start);

/*
Starten mit:

python -m http.server 8000

und dann aufrufen:

http://localhost:8000

Wenn es nicht funktioniert dann mit dem python extra script:

python server.py

*/

# FILE C:\Homepage\math-education-v5\src\controls\CameraController.js

// src/controls/CameraController.js
export class CameraController {
    constructor(camera, onChange) {
        this.camera = camera;
        this.onChange = onChange;

        window.addEventListener("keydown", this.handleKey.bind(this));
    }

    handleKey(e) {
        switch (e.key) {
            case "ArrowLeft":
                this.camera.angleY -= 5;
                break;
            case "ArrowRight":
                this.camera.angleY += 5;
                break;
            case "ArrowUp":
                this.camera.angleX -= 5;
                break;
            case "ArrowDown":
                this.camera.angleX += 5;
                break;
            default:
                return;
        }

        this.onChange(); // z.B. scene.render()
    }
}

# FILE C:\Homepage\math-education-v5\src\experiments\basisChange\index.js

// src/experiments/basisChange/index.js
"use strict";

import { setup } from "./setup.js";
import { run } from "./run.js";

export default { setup, run };

# FILE C:\Homepage\math-education-v5\src\experiments\basisChange\run.js

// src/experiments/basisChange/run.js
"use strict";

export function run(scene, state) {
  	// this.setup() kommt aus index.js (default export {setup, run})
  	// Weil nach const experiment = await loadExperiment("basisChange")
	//
  	// ist experiment === 	{
  	//                        	setup: [Function],
  	// 							run:   [Function]
	// 						}
	//
	// und wenn experiment.run(..) aufruft dann ist this = experiment innerhalb von der funktion run(..).
	// Das ist dynamische bindung von this, sehr mÃ¼hsam in js!
	const data = this.setup();

	// WICHTIG: Experiment setzt NUR Bedeutung (State), nicht Rendering.
	state.setBasisA(data.basisA);
	state.setBasisB(data.basisB);
	state.setVector(data.vector);

	// Kein scene.render() hier!
	// Das passiert automatisch ueber state.notify() -> Listener.
}

# FILE C:\Homepage\math-education-v5\src\experiments\basisChange\setup.js

// src/experiments/basisChange/setup.js
"use strict";

import { Basis } from "../../math/Basis.js";
import { Vector3 } from "../../math/Vector3.js";

export function setup() {
  const basisA = Basis.standard();

  // schiefe Basis (nur Beispiel)
  const ANZ_GRAD = -20;
  const basisB = Basis.standard().rotateZ( (ANZ_GRAD / 180) * Math.PI); // ANZ_GRAD drehen

  const vector = new Vector3(7, 4, 0);

  return { basisA, basisB, vector };
}

# FILE C:\Homepage\math-education-v5\src\experiments\LinearMap\index.js

// src/experiments/LinearMap/index.js

import { setup } from "./setup.js";
import { run } from "./run.js";

export default { setup, run };

# FILE C:\Homepage\math-education-v5\src\geometry\Geometry.js

export class Geometry {
	constructor({ positions, colors, primitiveType }) {
		this.positions = positions;
		this.colors = colors;
		this.primitiveType = primitiveType;
		this.vertexCount = positions.length / 3;
	}
}

# FILE C:\Homepage\math-education-v5\src\loaders\GeometryLoader.js

/*
Warum heisst es GeometryLoader.js, es tut doch nur json laden und kein Geometrie-Objekt?

JSON ist Data pur.
Unsere Geometry ist Data pur.
Also sind sie konzeptionell dasselbe.

*/

export async function loadGeometry(url) {
	const res = await fetch(url);
	if (!res.ok) {
		throw new Error("Failed to load geometry: " + url);
	}
	return await res.json();
}

# FILE C:\Homepage\math-education-v5\src\math\Basis.js

import { Matrix3 } from "./Matrix3.js";
import { Vector3 } from "./Vector3.js";

export class Basis {
    constructor(e1, e2, e3) {
        this.e1 = e1;
        this.e2 = e2;
        this.e3 = e3;
    }

    toMatrix() {
        return new Matrix3([
            [this.e1.x, this.e2.x, this.e3.x],
            [this.e1.y, this.e2.y, this.e3.y],
            [this.e1.z, this.e2.z, this.e3.z],
        ]);
    }

    // ------------------------
    // Basis aus Matrix erzeugen
    // (Spalten der Matrix = Basisvektoren)
    // ------------------------
    static fromMatrix(matrix) {
        const m = matrix.m;

        return new Basis(
            new Vector3(m[0][0], m[1][0], m[2][0]), // erste Spalte
            new Vector3(m[0][1], m[1][1], m[2][1]), // zweite Spalte
            new Vector3(m[0][2], m[1][2], m[2][2])  // dritte Spalte
        );
    }

    static standard() {
        return new Basis(
            new Vector3(1,0,0),
            new Vector3(0,1,0),
            new Vector3(0,0,1)
        );
    }

    // ------------------------
    // Basis mit Matrix transformieren
    // (aktive lineare Abbildung)
    // ------------------------
    transform(matrix) {
        return new Basis(
            matrix.multiplyVector(this.e1),
            matrix.multiplyVector(this.e2),
            matrix.multiplyVector(this.e3)
        );
    }

    // ------------------------
    // Rotation um X-Achse
    // ------------------------
    rotateX(angleRad) {
        const c = Math.cos(angleRad);
        const s = Math.sin(angleRad);

        const rot = (v) =>
        new Vector3(
            v.x,
            c * v.y - s * v.z,
            s * v.y + c * v.z
        );

        return new Basis(
            rot(this.e1),
            rot(this.e2),
            rot(this.e3)
        );
    }

    // ------------------------
    // Rotation um Y-Achse
    // ------------------------
    rotateY(angleRad) {
        const c = Math.cos(angleRad);
        const s = Math.sin(angleRad);

        const rot = (v) =>
        new Vector3(
            c * v.x + s * v.z,
            v.y,
            -s * v.x + c * v.z
        );

        return new Basis(
            rot(this.e1),
            rot(this.e2),
            rot(this.e3)
        );
    }

    // ------------------------
    // Rotation um Z-Achse
    // ------------------------
    rotateZ(angleRad) {
        const c = Math.cos(angleRad);
        const s = Math.sin(angleRad);

        const rot = (v) =>
            new Vector3(
                c * v.x - s * v.y,
                s * v.x + c * v.y,
                v.z
            );

        return new Basis(
            rot(this.e1),
            rot(this.e2),
            rot(this.e3)
        );
    }
}

# FILE C:\Homepage\math-education-v5\src\physics\PhysicsWord.js

// src/physics/PhysicsWorld.js

export class PhysicsWorld {

	constructor() {

		// Typische Werte fÃ¼r Restitution:

		// Stahl auf Stahl: 	~0.9
		// Gummi auf Beton:		~0.7
		// Knete:				~0
		// Superball:			~0.95
		// Hartgummi: 			0.7 - 0.8
		// Holz auf Holz		0.5 â€“ 0.7
		// Tennisball (neu):	~0.7

		this.restitution = 0.85;
		this.bodies = [];
	}

	add(body) {
		this.bodies.push(body);
	}

	update(dt) {

		// ------------------------------------------------------------
		// 1) Bewegung: klassische Euler-Integration
		// p = p + v * dt
		// ------------------------------------------------------------
		for (const b of this.bodies) {
			b.position = this.add(
				b.position,
				this.scale(b.velocity, dt)
			);
		}

		// ------------------------------------------------------------
		// 2) Paarweise Kollision prÃ¼fen
		// ------------------------------------------------------------
		for (let i = 0; i < this.bodies.length; i++) {
			for (let j = i + 1; j < this.bodies.length; j++) {
				this.resolveCollision(this.bodies[i], this.bodies[j]);
			}
		}
	}

	// ============================================================
	// Vektor-Operationen
	// ============================================================

	addInPlace(target, v) {
		target.x += v.x;
		target.y += v.y;
		target.z += v.z;
	}

	subInPlace(target, v) {
		target.x -= v.x;
		target.y -= v.y;
		target.z -= v.z;
	}

	scaleInPlace(target, s) {
		target.x *= s;
		target.y *= s;
		target.z *= s;
	}

	scaleTo(out, v, s) {
		out.x = v.x * s;
		out.y = v.y * s;
		out.z = v.z * s;
	}

	add(a, b) {
		return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
	}

	sub(a, b) {
		return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
	}

	scale(v, s) {
		return { x: v.x * s, y: v.y * s, z: v.z * s };
	}

	dot(a, b) {
		return a.x*b.x + a.y*b.y + a.z*b.z;
	}

	length(v) {
		return Math.sqrt(this.dot(v, v));
	}

	normalize(v) {
		const len = this.length(v);
		if (len < 1e-8) return null;
		return this.scale(v, 1 / len);
	}

	dot(a, b) {
		return a.x*b.x + a.y*b.y + a.z*b.z;
	}

	// ============================================================
	// Kugel-Kugel-Kollision (elastisch) 3d (didaktische Version, unten ist schneller Version)
	// ============================================================

	resolveCollision(bodyA, bodyB) {

		// ------------------------------------------------------------
		// 1) Abstand der Mittelpunkte
		// ------------------------------------------------------------
		const centerOffset = this.sub(bodyB.position, bodyA.position);
		const distance = this.length(centerOffset);

		const minimumDistance = bodyA.radius + bodyB.radius;

		// Keine BerÃ¼hrung â†’ nichts tun
		if (distance >= minimumDistance) return;

		// ------------------------------------------------------------
		// 2) Kollisions-Normale (Einheitsvektor). Ist die Gerade die die 2 Mittelpunkte verbindet: n= (pBâ€‹âˆ’pA) / (â€‹âˆ¥pBâ€‹ âˆ’ pAâ€‹â€‹âˆ¥â€‹)
		// ------------------------------------------------------------
		const collisionNormalVector = this.normalize(centerOffset);
		if (!collisionNormalVector) return;

		// ------------------------------------------------------------
		// 3) Relative Geschwindigkeit (Vektor)
		// ------------------------------------------------------------
		const relativeVelocity = this.sub(bodyA.velocity, bodyB.velocity);

		// ------------------------------------------------------------
		// 4) Relative Geschwindigkeit entlang der Normalen (Skalar)
		// ------------------------------------------------------------
		const relativeVelocityAlongNormal = this.dot(relativeVelocity, collisionNormalVector);

		// Wenn sie sich bereits trennen â†’ kein Impuls
		if (relativeVelocityAlongNormal > 0) return;

		// ------------------------------------------------------------
		// 5) Impulsfaktor (aus Impuls- und Energieerhaltung)
		// ------------------------------------------------------------
		const massA = bodyA.mass;
		const massB = bodyB.mass;
		const totalMass = massA + massB;

		if (totalMass === 0) return;

		// Ohne Restitution
		// const factorA = (2 * massB) / totalMass;
		// const factorB = (2 * massA) / totalMass;

		// Mit Restitution
		const factorA = ((1 + this.restitution) * massB) / totalMass;
		const factorB = ((1 + this.restitution) * massA) / totalMass;

		// ------------------------------------------------------------
		// 6) Impulsvektor entlang der Normalen
		// ------------------------------------------------------------
		const normalVelocityVector = this.scale(collisionNormalVector, relativeVelocityAlongNormal);

		// ------------------------------------------------------------
		// 7) Neue Geschwindigkeiten (exakte Formel)
		// ------------------------------------------------------------
		bodyA.velocity = this.sub(
			bodyA.velocity,
			this.scale(normalVelocityVector, factorA)
		);

		bodyB.velocity = this.add(
			bodyB.velocity,
			this.scale(normalVelocityVector, factorB)
		);

		// ------------------------------------------------------------
		// 8) Positionskorrektur (gegen Ãœberlappung)
		// ------------------------------------------------------------
		const overlap = minimumDistance - distance;

		const correction = this.scale(collisionNormalVector, overlap / 2);

		his.subInPlace(bodyA.position, correction);

		this.addInPlace(bodyB.position, correction);
	}

	// ============================================================
	// Kugel-Kugel-Kollision (elastisch oder teilweise elastisch)
	// 3D-Version, ohne Garbage, In-Place Berechnung
	// ============================================================
	resolveCollisionFast(bodyA, bodyB) {

		// ------------------------------------------------------------
		// 1) Abstand der Mittelpunkte berechnen
		// ------------------------------------------------------------
		// Wir bilden den Vektor von A nach B:
		//
		//   d = pB - pA
		//
		// dx, dy, dz sind die Komponenten dieses Verbindungsvektors.
		//
		const dx = bodyB.position.x - bodyA.position.x;
		const dy = bodyB.position.y - bodyA.position.y;
		const dz = bodyB.position.z - bodyA.position.z;

		// Quadrat der Distanz:
		//
		//   distSq = dxÂ² + dyÂ² + dzÂ²
		//
		// Das ist ||pB - pA||Â²
		//
		const distSq = dx*dx + dy*dy + dz*dz;

		// Echte Distanz (Betrag des Vektors)
		//
		//   dist = âˆš(distSq)
		//
		const dist = Math.sqrt(distSq);

		// Falls Distanz extrem klein ist,
		// ist die Richtung (Normale) nicht definiert.
		// Dann brechen wir ab.
		if (dist < 1e-8) return;

		// Minimaler erlaubter Abstand der Mittelpunkte:
		//
		// Zwei Kugeln berÃ¼hren sich genau dann,
		// wenn der Abstand ihrer Mittelpunkte
		// gleich der Summe ihrer Radien ist.
		//
		const minDist = bodyA.radius + bodyB.radius;

		// Wenn sie weiter auseinander sind â†’ keine Kollision
		if (dist >= minDist) return;

		// ------------------------------------------------------------
		// 2) Kollisions-Normale berechnen
		// ------------------------------------------------------------
		// Die Kollisions-Normale ist der Einheitsvektor
		// entlang der Verbindungslinie der Mittelpunkte.
		//
		// Mathematisch:
		//
		//   n = (pB - pA) / ||pB - pA||
		//
		// Das ist die Richtung, in der die Kontaktkraft wirkt.
		//
		const nx = dx / dist;
		const ny = dy / dist;
		const nz = dz / dist;

		// ------------------------------------------------------------
		// 3) Relative Geschwindigkeit berechnen
		// ------------------------------------------------------------
		// Wir betrachten die Geschwindigkeit von A relativ zu B:
		//
		//   v_rel = vA - vB
		//
		const rvx = bodyA.velocity.x - bodyB.velocity.x;
		const rvy = bodyA.velocity.y - bodyB.velocity.y;
		const rvz = bodyA.velocity.z - bodyB.velocity.z;

		// ------------------------------------------------------------
		// 4) Anteil dieser Geschwindigkeit entlang der Normale
		// ------------------------------------------------------------
		// Wir projizieren die relative Geschwindigkeit
		// auf die Kollisions-Normale.
		//
		// Skalarprodukt:
		//
		//   relativeNormalVelocity = v_rel Â· n
		//
		// Das Ergebnis ist eine ZAHL (kein Vektor).
		//
		// Bedeutung:
		//   < 0 â†’ sie bewegen sich aufeinander zu
		//   > 0 â†’ sie entfernen sich
		//
		const relativeNormalVelocity =
			rvx*nx + rvy*ny + rvz*nz;

		// Wenn sie sich bereits voneinander entfernen,
		// dann wenden wir keinen Impuls mehr an.
		if (relativeNormalVelocity > 0) return;

		// ------------------------------------------------------------
		// 5) Massen
		// ------------------------------------------------------------
		const m1 = bodyA.mass;
		const m2 = bodyB.mass;

		const totalMass = m1 + m2;

		// ------------------------------------------------------------
		// 6) Restitution berÃ¼cksichtigen
		// ------------------------------------------------------------
		// restitution e:
		//
		// e = 1  â†’ perfekt elastisch
		// e = 0  â†’ komplett inelastisch (kein RÃ¼ckprall)
		//
		// Die StoÃŸstÃ¤rke wird skaliert mit (1 + e).
		//
		const factor =
			((1 + this.restitution) * relativeNormalVelocity)
			/ totalMass;

		// ------------------------------------------------------------
		// 7) Geschwindigkeiten aktualisieren
		// ------------------------------------------------------------
		//
		// Hergeleitete Formel:
		//
		// vA' = vA - factor * m2 * n
		// vB' = vB + factor * m1 * n
		//
		// Interpretation:
		// - Schwere Kugel Ã¤ndert sich weniger
		// - Leichte Kugel Ã¤ndert sich stÃ¤rker
		//
		bodyA.velocity.x -= factor * m2 * nx;
		bodyA.velocity.y -= factor * m2 * ny;
		bodyA.velocity.z -= factor * m2 * nz;

		bodyB.velocity.x += factor * m1 * nx;
		bodyB.velocity.y += factor * m1 * ny;
		bodyB.velocity.z += factor * m1 * nz;

		// ------------------------------------------------------------
		// 8) Positionskorrektur (gegen Ãœberlappung)
		// ------------------------------------------------------------
		//
		// Da wir diskret simulieren,
		// kÃ¶nnen sich Kugeln leicht Ã¼berlappen.
		//
		// overlap = wie viel sie zu nahe sind
		//
		const overlap = minDist - dist;

		// Wir verteilen die Korrektur symmetrisch:
		// Jede Kugel bewegt sich um die HÃ¤lfte.
		//
		const correction = overlap / 2;

		bodyA.position.x -= correction * nx;
		bodyA.position.y -= correction * ny;
		bodyA.position.z -= correction * nz;

		bodyB.position.x += correction * nx;
		bodyB.position.y += correction * ny;
		bodyB.position.z += correction * nz;
	}
}

# FILE C:\Homepage\math-education-v5\src\render\Camera.js

// render/Camera.js
import { WorldConfig } from "../config.js";
import * as mat4 from "../math/mat4.js";
import { rad } from "../math/LenearAlgebra.js";

class Camera {
    constructor() {
        this.angleX = 0;
        this.angleY = 0;
        this.distance = WorldConfig.EXTENT * 6; // So in etwa dass man was sieht
    }

    getViewMatrix() {
        const viewMatrix = mat4.create();

        if(Math.abs(this.distance) > 0) mat4.translate(viewMatrix, viewMatrix, [0, 0, -this.distance]);
        if(Math.abs(this.angleX) > 0) mat4.rotate(viewMatrix, viewMatrix, rad(this.angleX), [1, 0, 0]);
        if(Math.abs(this.angleY) > 0) mat4.rotate(viewMatrix, viewMatrix, rad(this.angleY), [0, 1, 0]);

        return viewMatrix;
    }
}

export { Camera };

# FILE C:\Homepage\math-education-v5\src\render\Drawable.js

// src/render/Drawable.js
"use strict";

class Drawable {

    constructor(gl, programInfo, geometry) {

        this.gl = gl;
        this.programInfo = programInfo;
        this.geometry = geometry;

        const primitiveName = geometry.primitives?.toUpperCase();
        this.primitiveType =
            gl[primitiveName] !== undefined
                ? gl[primitiveName]
                : gl.TRIANGLES;

        this.vertexCount =
            geometry.num_vertices ??
            (geometry.positions.length / geometry.num_dim);

        this.initBuffers();
    }

    initBuffers() {
        const gl = this.gl;

        // Positions
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(this.geometry.positions),
            gl.DYNAMIC_DRAW   // ðŸ”¥ wichtig
        );

        // Colors
        if (this.geometry.colors) {
            this.colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.bufferData(
                gl.ARRAY_BUFFER,
                new Float32Array(this.geometry.colors),
                gl.STATIC_DRAW
            );
        }
    }

    // ðŸ”¥ NEU: Positionen aktualisieren ohne neuen Buffer
    updatePositions(newPositions) {
        const gl = this.gl;

        this.geometry.positions = newPositions;

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferSubData(
            gl.ARRAY_BUFFER,
            0,
            new Float32Array(newPositions)
        );
    }

    draw(projectionMatrix, viewMatrix) {
        const gl = this.gl;
        const prog = this.programInfo;

        gl.uniformMatrix4fv(
            prog.uniformLocations.projectionMatrix,
            false,
            projectionMatrix
        );

        gl.uniformMatrix4fv(
            prog.uniformLocations.modelViewMatrix,
            false,
            viewMatrix
        );

        // Position
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(
            prog.attribLocations.vertexPosition,
            this.geometry.num_dim,
            gl.FLOAT,
            false,
            0,
            0
        );

        gl.enableVertexAttribArray(
            prog.attribLocations.vertexPosition
        );

        // Color
        if (this.colorBuffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.vertexAttribPointer(
                prog.attribLocations.vertexColor,
                this.geometry.num_color,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(
                prog.attribLocations.vertexColor
            );
        }

        gl.drawArrays(
            this.primitiveType,
            0,
            this.vertexCount
        );
    }
}

export { Drawable };

# FILE C:\Homepage\math-education-v5\src\render\Projection.js

"use strict";

/*
=====================================================
PROJECTION.JS â€“ DARSTELLUNGS-MATHE (KAMERA / SICHT)
=====================================================

WICHTIGER KONTEXT (DIDAKTISCH):

Dieses Modul gehÃ¶rt bewusst NICHT in /math.

Warum?
- Die Mathematik hier beschreibt KEINE objektive Welt
- Sie beschreibt, wie eine KAMERA die Welt sieht
- Ohne Rendering (Bildschirm, Sichtkegel, Clipping)
  ergibt diese Mathematik keinen Sinn

Merksatz:
â†’ Projektion ist keine Welt-Mathematik
â†’ Projektion ist Darstellungs-Mathematik

-----------------------------------------------------
Pipeline-Kontext:

Weltkoordinaten
   â†“ (View-Matrix: Welt â†’ Kamera)
Kamerakoordinaten
   â†“ (Projektionsmatrix: Kamera â†’ Clip Space)
Clip Space (-1 .. 1)
   â†“ (Viewport)
Bildschirm

Dieses Modul liefert AUSSCHLIESSLICH:
â†’ Kamerakoordinaten â†’ Clip Space
=====================================================
*/

// ===================================================
// PERSPEKTIVISCHE PROJEKTION
// ===================================================
/*
Dies ist die klassische Perspective Projection Matrix.

Was sie leistet:

- Alle Punkte im Sichtkegel (Frustum) der Kamera
  werden in den normierten Raum [-1, 1] abgebildet
- Das Clipping-Volume ist ein WÃ¼rfel von -1 bis +1
- Das Aspect Ratio (Breite / HÃ¶he) wird korrekt berÃ¼cksichtigt
- z-Werte werden ebenfalls in [-1, 1] abgebildet
  (fÃ¼r Tiefentest & Clipping)

WICHTIG:
Diese Matrix geht davon aus, dass:
- die Kamera im Ursprung sitzt
- die Kamera entlang der -Z-Achse schaut
- die View-Matrix diese Voraussetzungen bereits hergestellt hat

Die ZENTRIERUNG der Kamera (Apex des Frustums)
passiert NICHT hier, sondern in der View-Matrix!

Diese Funktion ist also NUR fÃ¼r:
â†’ zentrierte Kamera
â†’ standardisierte Kamerakoordinaten
*/

function createPerspectiveProjection(gl) {

    // ------------------------------------------------
    // Kamera-Parameter (bewusst hier, nicht abstrahiert)
    // ------------------------------------------------

    // Field of View (vertikal), in Radiant
    const fov = 20 * (Math.PI / 180);

    // Aspect Ratio des Bildschirms
    // â†’ DAS ist DarstellungsabhÃ¤ngigkeit
    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

    // Near- und Far-Plane des Frustums
    const zNear = 0.3;
    const zFar  = 100.0;

    // ------------------------------------------------
    // Mathematische Vorbereitung
    // ------------------------------------------------

    const angle = fov / 2.0;

    /*
    ACHTUNG (WICHTIG UND DIDAKTISCH):

    Die Matrix ist im COLUMN-MAJOR Format gespeichert,
    wie es WebGL (und OpenGL) erwarten.

    Das bedeutet:
    - Die "Spalten" der mathematischen Matrix
      stehen hier untereinander im Array
    - Beim Lesen wirkt die Matrix "transponiert"

    Das ist KEIN Denkfehler, sondern ein Speicherlayout-Thema.
    */

    // Dies ist die komplette Projektions-Matrix (Perspective-Projextion-Matrix). Alle Koordinaten der Vertices im Frustum werden richtig
    // in den Bereich von -1 zu 1 projeziert. Auch die Tatsache, dass aspect ration nicht gleich 1 ist wird beachtet durch diese Matrix.
    // Auch die z-Koordinaten werden zwischen -1 und 1 projeziert (fÃ¼r allfÃ¤lliges weg clippen oder so).
    // Anfangs dachte ich, dass was fehlt, z.B. die Zentrierung von apex (Kamera) oder so. Aber diese Funktion ist nur fÃ¼r fÃ¼r zentrierte
    // Kamera zugelassen.
    // Dann dachte ich auch, dass ja das Ganze auf ein clipping volume projeziert werden muss (clipping volume: WÃ¼rfel von -1 zu 1) und dass
    // das dem Aspect Ratio wiederspricht, weil aspect ratio kann auch nicht gleich 1 sein. Aber es wird in den Formeln ebenfalls
    // beachtet wie ich raus fand.
    const projectionMatrix = [

        // Spalte 0
        1.0 / (aspect * Math.tan(angle)),  0.0,  0.0,   0.0,

        // Spalte 1
        0.0,  1.0 / Math.tan(angle),        0.0,   0.0,

        // Spalte 2
        0.0,  0.0,  (zFar + zNear) / (zNear - zFar),  -1.0,

        // Spalte 3
        0.0,  0.0,  (2 * zFar * zNear) / (zNear - zFar),  0.0
    ];

    return projectionMatrix;
}

// ===================================================
// ORTHOGRAFISCHE PROJEKTION
// ===================================================
/*
Orthografische Projektion:

- KEINE Perspektive
- Parallele Kanten bleiben parallel
- Keine Tiefenverzerrung
- Oft verwendet fÃ¼r:
  - CAD
  - technische Zeichnungen
  - UI-Overlays
  - Debug-Ansichten

Hier wird ein Quader direkt
auf den Clip-WÃ¼rfel [-1,1] abgebildet.
*/

function createOrthographicProjection(left, right, bottom, top, zNear, zFar) {

    const orthographicMatrix = [

        // Spalte 0
        2.0 / (right - left),  0.0,  0.0,  0.0,

        // Spalte 1
        0.0,  2.0 / (top - bottom),  0.0,  0.0,

        // Spalte 2
        0.0,  0.0,  -2.0 / (zFar - zNear),  0.0,

        // Spalte 3
        -(right + left) / (right - left),
        -(top + bottom) / (top - bottom),
        -(zFar + zNear) / (zFar - zNear),
        1.0
    ];

    return orthographicMatrix;
}

// ===================================================
// FRUSTUM-PROJEKTION (ALLGEMEIN)
// ===================================================
/*
Allgemeine Frustum-Projektion:

- Left / Right / Top / Bottom kÃ¶nnen unterschiedlich sein
- Kamera muss evtl. NICHT zentriert sein
- Grundlage fÃ¼r Off-Center-Projektionen
- Stereo-Rendering
- Shadow Maps

HINWEIS:
Falls das Frustum nicht symmetrisch ist,
muss zusÃ¤tzlich eine View-Transformation erfolgen,
die den Apex (Kamera) ins Koordinatenzentrum verschiebt.
*/

function createFrustumProjection(left, right, bottom, top, zNear, zFar) {
    // Diese Funktion macht geanu das Gleiche wie createPerspectiveProjection(..) einfach mit anderen Argumenten.
	// Left und Right mÃ¼ssen gleich lang sein. Und auch top, bottom aber nur hier, im Allgemeinen mÃ¼sste diese Funktion das auch beachten.
	// Falls die Kamera nicht im Zentrum steht (d.h. -left != right oder -bottom != top) dann mÃ¼sste man die Funktion noch fertig schreiben.
	// In einem solchen Fall mÃ¼sste man dann noch die Zentrierung der Kamera ausfÃ¼hren (Translate the apex of the frustum to the origin).
	// Die zentrierung der Kamera to the origin (apex ist die Kamera) kann man sich so vorstellen: Ist as apex nach rechts (x-Achse) v
    // erschoben, so schiebe man das Koordinatensystem auch nach Rechts Richtung der x-Achse so dass der Koordinaten-Ursprung auf das
    // Apex zu liegen kommt. Als Folge verschieben sich die Koordinaten der einzelnen Vertices nach "Links" der x-Achse nach, also ins Minus.
    // Das Gleiche tue man natÃ¼rlich fÃ¼r Y-Achse falls nÃ¶tig.
	// Das "nach Rechts" kÃ¶nnte natÃ¼rlich auch "nach Links" sein, das war nur ein Beispiel o.B.d.A. sozusagen.
    return [

        // Spalte 0
        (2 * zNear) / (right - left),  0.0,  0.0,  0.0,

        // Spalte 1
        0.0,  (2 * zNear) / (top - bottom),  0.0,  0.0,

        // Spalte 2
        (right + left) / (right - left),
        (top + bottom) / (top - bottom),
        -(zFar + zNear) / (zFar - zNear),
        -1.0,

        // Spalte 3
        0.0,  0.0,  -(2 * zFar * zNear) / (zFar - zNear),  0.0
    ];
}

// ===================================================
// EXPORTS
// ===================================================

export {
    createPerspectiveProjection,
    createOrthographicProjection,
    createFrustumProjection
};

# FILE C:\Homepage\math-education-v5\src\render\Scene.js

// src/render/Scene.js
"use strict";

import { Drawable } from "./Drawable.js";
import { Camera } from "./Camera.js";
import { CameraController } from "../controls/CameraController.js";
import { createPerspectiveProjection } from "./Projection.js";

class Scene {

    constructor(canvas, gl, programInfo) {

        this.canvas = canvas;
        this.gl = gl;
        this.programInfo = programInfo;

        this.gl.useProgram(this.programInfo.program);

        this.camera = new Camera();
        this.drawables = [];

        this.controller = new CameraController(
            this.camera,
            () => {}   // ðŸ”¥ kein render hier mehr
        );

        this.lastTime = 0;
    }

    addGeometry(geometry) {
        const drawable = new Drawable(this.gl, this.programInfo, geometry);
        this.drawables.push(drawable);
        return drawable;
    }

    start() {
        const loop = (time) => {

            const dt = (time - this.lastTime) * 0.001;
            this.lastTime = time;

            this.update(dt);
            this.render();

            requestAnimationFrame(loop);
        };

        requestAnimationFrame(loop);
    }

    update(dt) {
        // hier kÃ¶nntest du spÃ¤ter Animationen einbauen
    }

    render() {
        const gl = this.gl;

        const projectionMatrix = createPerspectiveProjection(gl);
        const viewMatrix = this.camera.getViewMatrix();

        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        for (const drawable of this.drawables) {
            drawable.draw(projectionMatrix, viewMatrix);
        }
    }
}

export { Scene };

# FILE C:\Homepage\math-education-v5\src\state\MathState.js

// src/state/MathState.js
"use strict";

import { Basis } from "../math/Basis.js";

export class MathState {
    constructor() {
        this.basisA = null;
        this.basisB = null;
        this.vector = null;
        this.matrix = null;
        this.resultVector = null;

        this.listeners = [];
    }

    onChange(fn) {
        this.listeners.push(fn);
    }

    notify() {
        for (const fn of this.listeners) {
            fn(this);
        }
    }

    setBasisA(basis) {
        this.basisA = basis;
        this.notify();
    }

    setBasisB(basis) {
        this.basisB = basis;
        this.notify();
    }

    setVector(v) {
        this.vector = v;

        // ðŸ”¥ HIER die Abbildung
        if (this.matrix) {
            this.resultVector = this.matrix.multiplyVector(v);
        }

        this.notify();
    }

    setMatrix(m) {
        this.matrix = m;

        // ðŸ”¥ BasisB aktualisieren
        this.basisB = Basis.standard().transform(m);
        // oder:
        // this.basisB = Basis.fromMatrix(m);

        if (this.vector) {
            this.resultVector = m.multiplyVector(this.vector);
        }

        this.notify();
    }

    setResultVector(v) {
        this.resultVector = v;
        this.notify();
    }
}

# FILE C:\Homepage\math-education-v5\src\ui\LinearMapView.js

// src/ui/LinearMapView.js
"use strict";

import { Vector3 } from "../math/Vector3.js";
import { Matrix3 } from "../math/Matrix3.js";

function cell(value, editable, onChange) {
    if (!editable) {
        return `<div class="cell">${value.toFixed(2)}</div>`;
    }
    return `<input class="cell" type="number" step="0.1" value="${value}"
        data-hook="edit">`;
}

export function bindLinearMapView(state) {

    const mDiv = document.getElementById("matrixA");
    const vDiv = document.getElementById("vectorV");
    const rDiv = document.getElementById("vectorR");

    state.onChange((s) => {
        if (!s.matrix || !s.vector || !s.resultVector) return;

        const is2D =
            s.matrix.m[0][2] === 0 &&
            s.matrix.m[1][2] === 0 &&
            s.matrix.m[2][0] === 0 &&
            s.matrix.m[2][1] === 0 &&
            s.matrix.m[2][2] === 1 &&
            s.vector.z === 0;

        // ---------- MATRIX ----------
        mDiv.innerHTML = "";

        const rows = is2D ? 2 : 3;
        const cols = is2D ? 2 : 3;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {

                const inp = document.createElement("input");
                inp.className = "cell";
                inp.type = "number";
                inp.step = "0.1";
                inp.value = s.matrix.m[row][col];

                inp.oninput = () => {

                    // Deep copy der 2D-Matrix
                    const newM = s.matrix.m.map(r => [...r]);

                    newM[row][col] = parseFloat(inp.value);

                    state.setMatrix(new Matrix3(newM));
                };

                mDiv.appendChild(inp);
            }

            mDiv.appendChild(document.createElement("br"));
        }

       // ---------- VECTOR ----------
        vDiv.innerHTML = "";

        const dims = is2D ? ["x", "y"] : ["x", "y", "z"];

        const inputs = [];

        dims.forEach((k) => {
            const inp = document.createElement("input");
            inp.className = "cell";
            inp.type = "number";
            inp.step = "0.1";
            inp.value = s.vector[k];

            inputs.push(inp);

            inp.oninput = () => {
                const x = parseFloat(inputs[0].value);
                const y = parseFloat(inputs[1].value);
                const z = is2D ? 0 : parseFloat(inputs[2].value);

                state.setVector(new Vector3(x, y, z));
            };

            vDiv.appendChild(inp);
            vDiv.appendChild(document.createElement("br"));
        });

        // ---------- RESULT ----------
        rDiv.innerHTML = "";
        dims.forEach((k) => {
            const d = document.createElement("div");
            d.className = "cell";
            d.textContent = s.resultVector[k].toFixed(2);
            rDiv.appendChild(d);
            rDiv.appendChild(document.createElement("br"));
        });
    });
}

# PROJECT STRUCTURE

  Doku.odt
  GptKonvsAppArchtUndLinAbb.docx
  favicon.ico
  gpt_bundle.txt
  index.html
  server.py
  src/
    config.js
    app/
      index.js
    builders/
      CoordinateSystemBuilder.js
      CubeBuilder.js
      CubeWireframeBuilder.js
      VectorBuilder.js
    controls/
      CameraController.js
    experiments/
      loadExperiment.js
      basisChange/
        index.js
        run.js
        setup.js
      LinearMap/
        index.js
        run.js
        setup.js
    geometry/
      Geometry.js
    gl/
      createProgram.js
      createShader.js
    loaders/
      GeometryLoader.js
      loadText.js
    math/
      Basis.js
      LenearAlgebra.js
      Matrix3.js
      Vector3.js
      mat3.js
      mat4.js
    physics/
      PhysicsWord.js
    render/
      Camera.js
      Drawable.js
      Projection.js
      Scene.js
    shaders/
      fShaderCode.glsl
      vShaderCode.glsl
    state/
      MathState.js
    ui/
      Inspector.js
      LinearMapView.js
    utils/
      common.js
      graph2d.js
      index.js
      mat2.js
      mat2d.js
      quat.js
      quat2.js
      series.js
      vec2.js
      vec3.js
      vec4.js
      webgl-utils.js
      webgl-utils2.js